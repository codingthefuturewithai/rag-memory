# Metadata System Analysis - Session Working Document

## System-Managed Metadata Fields for Vector Store

These fields are **automatically generated by the system**. LLMs/clients should NEVER provide these.

### From Web Crawling (web_crawler.py lines 189-206)
1. `source` - The page URL
2. `content_type` - Set to "web_page" for crawled pages
3. `crawl_root_url` - Root URL of the crawl session
4. `crawl_timestamp` - ISO format timestamp of when crawl happened
5. `crawl_session_id` - Unique UUID for the crawl batch
6. `crawl_depth` - Integer depth level in the crawl tree
7. `title` - Page title (extracted from crawl result)
8. `description` - Page meta description (extracted from crawl result)
9. `domain` - Parsed from URL netloc (automatically extracted)
10. `language` - Extracted from page metadata
11. `status_code` - HTTP status code from crawl
12. `content_length` - Length of the content in characters
13. `crawler_version` - Version of Crawl4AI used
14. `parent_url` - Optional, parent page URL if depth > 0

### From File Ingestion (document_store.py lines 188-198)
15. `filename` - The file name (auto-extracted from path)
16. `file_path` - Full absolute path (auto-extracted from Path object)
17. `file_type` - File extension (auto-determined from suffix)

### From Chunking Process
18. `chunk_index` - Auto-assigned chunk sequence number
19. `char_start` - Character offset where chunk starts in source
20. `char_end` - Character offset where chunk ends in source

**TOTAL: 20 system-managed metadata fields**

---

## Create Collection Schema - What MCP Client Provides

Currently, the create_collection MCP tool requires:
1. `name` - Collection name
2. `description` - Collection description (mandatory)
3. `metadata_schema` (optional) - Contains:
   - `custom` - User-defined fields only
     - Each field has: `type`, `description` (optional), `required` (optional), `enum` (optional)

**System-managed fields are NOT declared at collection creation time.**

---

## Mandatory Metadata Fields (Collection-Scoped, NOT System-Managed)

These three fields are **required at collection creation time** to define the collection's knowledge scope and domain boundaries. They are **conceptually separate** from system-managed fields because they represent user/LLM intent, not automatic system generation.

1. **`domain`** (string, singular, required, IMMUTABLE)
   - Example: "quantum computing", "molecular biology", "aviation"
   - Set once at collection creation, CANNOT be changed
   - Purpose: Single domain per collection keeps knowledge graph partitioned meaningfully
   - LLMs providing the domain when creating the collection helps enforce scope

2. **`topics`** (array of strings, at least one item required, ADDITIVE-ONLY)
   - Example: `["quantum entanglement", "quantum algorithms", "quantum hardware"]`
   - At least one topic must be provided at collection creation
   - New topics can be ADDED to the array, but never removed (additive-only)
   - Purpose: Guide LLMs on what subjects belong in this collection
   - When ingesting documents, LLM should provide topic values that fit within this collection's declared topics

3. **`domain_scope`** (string description, required, IMMUTABLE)
   - Example: "Covers quantum computing theory and applications. Excludes quantum biology, quantum cryptography applications outside computing."
   - Set once at collection creation, CANNOT be changed
   - Purpose: Natural language specification of what IS and ISN'T in this domain
   - Helps LLMs understand boundaries when deciding what documents belong in the collection

**Why Separate from System-Managed?**
- System-managed fields (crawl_depth, status_code, filename, etc.) are extracted/auto-set by the ingestion pipeline
- Mandatory fields (domain, topics, domain_scope) represent explicit user intent about collection scope
- Mandatory fields are declared at collection **creation**, system fields are set during **ingestion**
- Mandatory fields guide LLM behavior; system fields track provenance

---

## Custom Fields (User-Defined)

These are defined per-collection and can be required or optional.
Examples: `doc_type`, `priority`, `custom_topics`, etc.
- Declared in metadata_schema at collection creation
- Can be required or optional (new ones must be optional due to additive-only constraint)
- Never removed, only added
- Distinct from both mandatory fields and system-managed fields

---

## MCP Search Filtering Capability

**VERIFIED:** The `search_documents` MCP tool DOES support filtering by ANY metadata field.

**How it works:**
- MCP tool accepts `metadata_filter` parameter (dict)
- Gets passed to `SimilaritySearch.search_chunks()` (src/retrieval/search.py line 121)
- Applied via PostgreSQL JSONB containment operator `@>` (line 170)
- Example: `{"filename": "my_file.md"}` will filter to only results with that filename

**This means:**
- ALL 20 system-managed metadata fields CAN be used for filtering
- If a field is set in metadata, MCP clients can filter by it
- The filtering works correctly: `filename = "my_file.md"` returns only chunks with that filename

---

---

## CODE CHANGE SUMMARY - MANDATORY FIELDS IMPLEMENTATION

### Overview

Implement mandatory metadata fields (domain, topics, domain_scope) as a **distinct category** from system-managed and custom fields. These fields define collection scope and partition the knowledge graph by domain/group_id.

**Three Metadata Categories:**

| Category | Managed By | Set At | Immutable | Additive | Purpose | Exposed in Schema? |
|----------|-----------|--------|-----------|----------|---------|-------------------|
| **Mandatory** | User/LLM | Collection creation | domain, domain_scope | topics array | Define collection scope and domain boundaries | YES - always |
| **Custom** | User/LLM | Collection creation or later | Fields themselves | Yes (additive-only) | User-declared metadata on documents (required or optional) | YES - always |
| **System-Managed** | Ingestion pipeline | Document ingestion | All fields | All (append-only) | Auto-extracted provenance, internal state | NO - never in schema |

**Key Design Decisions:**

1. **Mandatory fields are NOT system-managed:** Even though they're set once, they represent user intent for collection scope, not auto-extracted data.

2. **System fields are NOT exposed in schema:** Schema is the contract for "what do you provide to this collection?" System fields are internal implementation details. LLMs cannot realistically use them for filtering because:
   - They don't know what values exist (e.g., crawl_session_id, status_code)
   - Detection is unreliable (e.g., language detection ~80% accuracy)
   - Fields may change with implementation improvements
   - If system field filtering needed later, build separate discovery mechanism

3. **Schema contains ONLY what LLM needs to know:** Mandatory fields (what defines this collection) + Custom fields (what to provide when ingesting)

4. **Topics is an enum for filtering:** When ingesting, LLM must select topics from the collection's existing topics list. Topics is the ONLY field that grows (additive), but within bounds (enum constraint).

5. **Custom fields can be required or optional:** The "required" property is on the field definition, not the category name. Never call them "optional_fields" - they're "custom_fields" with a required:true/false property.

6. **Consistent terminology across all APIs:**
   - Use "mandatory_fields", "custom_fields", "system_fields" (or omit system entirely)
   - "required" is a boolean property, not a category
   - "immutable" and "additive_only" describe update constraints, not field names

**Separation Principle (Implementation):**
- Three metadata categories in database: `mandatory`, `custom`, `system`
- Implementation can reuse some validation logic
- But the conceptual categorization must be clear in code, docstrings, and responses

---

### 1. Database Schema Changes (MINIMAL)

**Current:**
```sql
collections.metadata_schema = {"custom": {}, "system": []}
```

**New:**
```sql
collections.metadata_schema = {
  "mandatory": {
    "domain": "quantum computing",
    "topics": ["quantum entanglement", "quantum algorithms"],
    "domain_scope": "..."
  },
  "custom": {...},
  "system": [...]
}
```

**Migration Strategy:**
- New collections: Set mandatory fields at creation
- Existing collections: Add migration that sets mandatory fields from user input (can be deferred, not blocking)

---

### 2. `src/core/collections.py` Changes

#### Change 2.1: Update `create_collection()` signature and logic

**Lines 24-83 - `create_collection()` method**

**Current signature:**
```python
def create_collection(self, name: str, description: str, metadata_schema: dict = None) -> int:
```

**New signature:**
```python
def create_collection(
    self,
    name: str,
    description: str,
    domain: str,                    # NEW - required, singular
    topics: list[str],              # NEW - required, at least one item
    domain_scope: str,              # NEW - required, description
    metadata_schema: dict = None,   # existing custom fields
) -> int:
```

**New logic:**
1. Validate `domain` is non-empty string
2. Validate `topics` is list with at least one non-empty string item
3. Validate `domain_scope` is non-empty string
4. Build metadata_schema with mandatory fields:
   ```python
   schema = {
       "mandatory": {
           "domain": domain,
           "topics": topics,
           "domain_scope": domain_scope
       },
       "custom": self._validate_metadata_schema(metadata_schema).get("custom", {}),
       "system": []
   }
   ```
5. Insert into database (unchanged INSERT logic, just different schema structure)

**Docstring update:**
```python
"""
Create a new collection with mandatory scope fields and optional custom metadata schema.

Mandatory Fields (required at creation, define collection scope):
    - domain: Single knowledge domain for this collection (e.g., "quantum computing")
      Cannot be changed after creation (immutable).
    - topics: Array of topic keywords for this domain (e.g., ["quantum entanglement", "algorithms"])
      At least one topic required. New topics can be added later but none can be removed (additive-only).
    - domain_scope: Natural language description of what is/isn't in this domain
      Cannot be changed after creation (immutable).

Custom Fields (optional, user-defined):
    Declare custom metadata fields per-collection. Format:
    {
        "custom": {
            "field_name": {
                "type": "string|number|boolean|array|object",
                "description": "optional",
                "required": false,  # new fields must be optional
                "enum": [...]       # optional
            }
        }
    }

Args:
    name: Unique collection name
    description: Collection description (mandatory, non-empty)
    domain: Knowledge domain (mandatory, singular, immutable)
    topics: List of topics for this domain (mandatory, at least one, additive-only)
    domain_scope: Description of domain boundaries (mandatory, immutable)
    metadata_schema: Optional custom fields schema (additive-only)

Returns:
    Collection ID

Raises:
    ValueError: If mandatory fields invalid, custom schema invalid, or collection already exists
"""
```

---

#### Change 2.2: Update `_validate_metadata_schema()` to handle mandatory fields

**Lines 168-237 - `_validate_metadata_schema()` method**

**New responsibilities:**
1. If schema has "mandatory" key, validate it (don't auto-generate)
2. If schema lacks "mandatory" key, don't add it (mandatory fields are NOT system-managed)
3. Validate custom fields as before
4. Validate system fields as before

**New logic:**
```python
def _validate_metadata_schema(self, schema: dict = None) -> dict:
    """
    Validate and normalize metadata schema with three categories:
    1. Mandatory fields (domain, topics, domain_scope) - set at creation, immutable
    2. Custom fields (user-defined) - additive-only
    3. System fields (auto-generated during ingestion) - for reference only
    """
    if schema is None:
        # Don't auto-generate mandatory fields - they're required at creation
        return {"mandatory": {}, "custom": {}, "system": []}

    # Validate mandatory fields if present
    if "mandatory" in schema:
        mandatory = schema["mandatory"]
        # Validate domain
        if "domain" not in mandatory or not mandatory["domain"]:
            raise ValueError("Mandatory field 'domain' required and cannot be empty")
        if not isinstance(mandatory["domain"], str):
            raise ValueError("Mandatory field 'domain' must be string")

        # Validate topics
        if "topics" not in mandatory or not mandatory["topics"]:
            raise ValueError("Mandatory field 'topics' required and must have at least one item")
        if not isinstance(mandatory["topics"], list):
            raise ValueError("Mandatory field 'topics' must be array")
        if not all(isinstance(t, str) and t.strip() for t in mandatory["topics"]):
            raise ValueError("Mandatory field 'topics' must contain non-empty strings")

        # Validate domain_scope
        if "domain_scope" not in mandatory or not mandatory["domain_scope"]:
            raise ValueError("Mandatory field 'domain_scope' required and cannot be empty")
        if not isinstance(mandatory["domain_scope"], str):
            raise ValueError("Mandatory field 'domain_scope' must be string")

    # Validate custom fields (existing logic, unchanged)
    if "custom" not in schema:
        schema["custom"] = {}
    if not isinstance(schema["custom"], dict):
        raise ValueError("metadata_schema.custom must be a dictionary")
    # ... rest of custom validation as-is

    # Validate system fields (existing logic, unchanged)
    if "system" not in schema:
        schema["system"] = []
    # ... rest of system validation as-is

    return schema
```

**Docstring update:**
```python
"""
Validate and normalize metadata schema with three field categories.

MANDATORY FIELDS (set at collection creation, immutable):
- domain: Knowledge domain (string, singular)
- topics: Topic array (list of strings, additive-only)
- domain_scope: Domain description (string)

CUSTOM FIELDS (user-defined, additive-only):
- User-declared fields with type validation

SYSTEM FIELDS (auto-generated during ingestion, for reference):
- Automatically set by ingestion pipeline (filename, crawl_depth, status_code, etc.)

Args:
    schema: Raw schema dict from user (may be None or missing categories)

Returns:
    Normalized schema dict with all three categories

Raises:
    ValueError: If mandatory fields missing/invalid, or custom/system schemas invalid
"""
```

---

#### Change 2.3: Add `validate_document_mandatory_fields()` new method

**New method (insert after `_validate_metadata_schema()`, around line 240):**

```python
def validate_document_mandatory_fields(
    self, collection_name: str, document_metadata: dict
) -> None:
    """
    Validate that document's domain/topics match collection's scope (guidance, not enforcement).

    This is a GUIDANCE mechanism, not a hard constraint:
    - LLM clients SHOULD provide domain/topics matching the collection
    - System WILL NOT reject mismatches (helps with retroactive documents)
    - But validation helps LLMs understand collection scope

    Args:
        collection_name: Collection to validate against
        document_metadata: Metadata dict from ingested document

    Raises:
        ValueError: If collection not found or has no mandatory fields
    """
    collection = self.get_collection(collection_name)
    if not collection:
        raise ValueError(f"Collection '{collection_name}' not found")

    mandatory = collection.get("metadata_schema", {}).get("mandatory", {})
    if not mandatory:
        # No mandatory fields defined yet - skip validation
        return

    # Get document's domain and topics (may be missing - that's ok)
    doc_domain = document_metadata.get("domain")
    doc_topics = document_metadata.get("topics", [])

    # Log warnings if mismatches (guidance only, not enforced)
    if doc_domain and doc_domain != mandatory.get("domain"):
        logger.warning(
            f"Document domain '{doc_domain}' does not match collection domain "
            f"'{mandatory.get('domain')}' - this may indicate scope mismatch"
        )

    if doc_topics and mandatory.get("topics"):
        collection_topics = set(mandatory.get("topics", []))
        doc_topic_set = set(doc_topics) if isinstance(doc_topics, list) else {doc_topics}

        # Check if document topics are subset of collection topics
        unknown_topics = doc_topic_set - collection_topics
        if unknown_topics:
            logger.warning(
                f"Document has topics {unknown_topics} not in collection topics "
                f"{collection_topics} - document may be out of scope"
            )
```

---

#### Change 2.4: Update `update_collection_metadata_schema()` for mandatory field immutability and topics merging

**Lines 239-351 - `update_collection_metadata_schema()` method**

**Current behavior:** Updates custom fields additively

**New behavior:**
1. Block ANY attempt to modify mandatory fields (domain, domain_scope)
2. For topics array, allow ADDITIVE merge only (new topics appended, existing never removed)
3. Update custom fields as before

**New logic:**
```python
def update_collection_metadata_schema(self, name: str, new_fields: dict) -> dict:
    """
    Update a collection's metadata schema (additive only, mandatory fields immutable).

    Rules:
    1. Mandatory fields (domain, domain_scope) CANNOT be changed - raises error if attempted
    2. Topics array (in mandatory) CAN be updated - new topics added, existing preserved (additive)
    3. Custom fields CAN be added - never removed or changed (additive)
    """
    collection = self.get_collection(name)
    if not collection:
        raise ValueError(f"Collection '{name}' not found")

    current_schema = collection["metadata_schema"]
    current_mandatory = current_schema.get("mandatory", {})

    # RULE 1: Block updates to immutable mandatory fields
    if "mandatory" in new_fields:
        new_mandatory = new_fields["mandatory"]

        # Block domain changes
        if "domain" in new_mandatory and new_mandatory["domain"] != current_mandatory.get("domain"):
            raise ValueError(
                f"Cannot change mandatory field 'domain' from "
                f"'{current_mandatory.get('domain')}' to '{new_mandatory['domain']}'. "
                f"Domain is immutable and defines collection scope."
            )

        # Block domain_scope changes
        if "domain_scope" in new_mandatory and new_mandatory["domain_scope"] != current_mandatory.get("domain_scope"):
            raise ValueError(
                f"Cannot change mandatory field 'domain_scope' once set. "
                f"Use domain_scope to define collection boundaries, then manage content via topics."
            )

        # RULE 2: Allow topics array to grow additively (merge, deduplicate)
        if "topics" in new_mandatory:
            if not isinstance(new_mandatory["topics"], list):
                raise ValueError("Mandatory field 'topics' must be an array")

            current_topics = current_mandatory.get("topics", [])
            new_topics = new_mandatory["topics"]

            # Merge: keep existing, append new (deduplicate)
            merged_topics = list(dict.fromkeys(current_topics + new_topics))  # Preserve order, deduplicate

            if not merged_topics:
                raise ValueError("Topics array cannot be empty")

            new_fields["mandatory"]["topics"] = merged_topics
            logger.info(
                f"Collection '{name}': Added {len(merged_topics) - len(current_topics)} topics. "
                f"Total: {len(merged_topics)}"
            )

    # Rest of method: validate custom fields, update database, return (existing logic, unchanged)
    ...
```

**Docstring update:**
```python
"""
Update a collection's metadata schema (additive only, mandatory fields immutable).

MANDATORY FIELD UPDATE RULES:
- domain: IMMUTABLE - cannot be changed after creation
- domain_scope: IMMUTABLE - cannot be changed after creation
- topics: ADDITIVE-ONLY - new topics can be added, existing topics preserved, never removed

CUSTOM FIELD UPDATE RULES:
- New custom fields can be added
- Existing custom fields cannot be removed (data integrity)
- Existing custom field types cannot be changed

Args:
    name: Collection name to update
    new_fields: New schema fields to add/update
        {
            "mandatory": {
                "topics": ["new_topic1", "new_topic2"]  # Merged with existing topics
            },
            "custom": {
                "new_field": {"type": "string"}
            }
        }

Returns:
    Updated collection info with merged schema

Raises:
    ValueError: If trying to change immutable mandatory fields (domain, domain_scope),
               remove custom fields, or violate other additive-only constraints
"""
```

---

### 3. `src/mcp/tools.py` Changes

#### Change 3.1: Update `create_collection_impl()` signature and docstring

**Lines 210-243 - `create_collection_impl()` function**

**Current signature:**
```python
def create_collection_impl(
    coll_mgr: CollectionManager,
    name: str,
    description: str,
    metadata_schema: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
```

**New signature:**
```python
def create_collection_impl(
    coll_mgr: CollectionManager,
    name: str,
    description: str,
    domain: str,                           # NEW - required
    topics: list = None,                   # NEW - required, list of strings
    domain_scope: str = None,              # NEW - required
    metadata_schema: Dict[str, Any] = None, # existing custom fields (optional)
) -> Dict[str, Any]:
```

**New implementation:**
```python
def create_collection_impl(
    coll_mgr: CollectionManager,
    name: str,
    description: str,
    domain: str,
    topics: list = None,
    domain_scope: str = None,
    metadata_schema: Dict[str, Any] = None,
) -> Dict[str, Any]:
    """
    Implementation of create_collection MCP tool.

    Creates a collection with mandatory scope fields (domain, topics, domain_scope) and optional custom metadata fields.

    MANDATORY FIELDS (required at creation, define collection scope):

    domain (string, required):
        Single knowledge domain for this collection. Examples: "quantum computing", "molecular biology", "aviation"
        Immutable - cannot be changed after creation.
        Purpose: Partitions knowledge graph by meaningful knowledge areas.

    topics (array of strings, required, at least one item):
        Key topics/subjects within this domain. Examples: ["quantum entanglement", "quantum algorithms", "quantum hardware"]
        At least one topic required at creation.
        New topics can be ADDED later (additive-only), but none can be removed.
        Purpose: Guide LLMs on what subjects belong in this collection's domain.

    domain_scope (string, required):
        Natural language specification of collection boundaries.
        Example: "Covers quantum computing theory and applications. Excludes quantum biology, quantum cryptography outside computing."
        Immutable - cannot be changed after creation.
        Purpose: Helps LLMs understand scope when deciding what documents to ingest.

    CUSTOM FIELDS (optional, user-defined):

    metadata_schema (dict, optional):
        Declare custom metadata fields for documents in this collection. Format:
        {
            "custom": {
                "doc_type": {
                    "type": "string",
                    "description": "Type of document",
                    "required": false,
                    "enum": ["article", "paper", "book"]
                },
                "priority": {
                    "type": "string",
                    "required": false
                }
            }
        }
        New fields must be optional (required=false or omitted).
        Custom fields are additive-only - new fields can be added later but never removed.

    Args:
        coll_mgr: CollectionManager instance
        name: Unique collection name
        description: Collection description (mandatory, non-empty)
        domain: Knowledge domain (mandatory, singular, immutable)
        topics: Topics for this domain (mandatory, list of strings, at least one, additive-only)
        domain_scope: Domain boundary description (mandatory, immutable)
        metadata_schema: Optional custom field declarations

    Returns:
        {
            "collection_id": int,
            "name": str,
            "description": str,
            "domain": str,
            "topics": [str],
            "domain_scope": str,
            "metadata_schema": dict,
            "created": true
        }

    Raises:
        ValueError: If mandatory fields invalid, custom schema invalid, or collection already exists

    Example:
        result = create_collection_impl(
            coll_mgr,
            name="quantum-computing",
            description="Quantum computing research and applications",
            domain="quantum computing",
            topics=["quantum entanglement", "quantum algorithms", "quantum hardware"],
            domain_scope="Covers QC theory and applications. Excludes quantum biology.",
            metadata_schema={
                "custom": {
                    "paper_type": {"type": "string", "enum": ["research", "review"]}
                }
            }
        )
    """
    try:
        # Validate mandatory fields
        if not domain or not isinstance(domain, str):
            raise ValueError("domain must be a non-empty string")
        if not topics or not isinstance(topics, list) or not all(isinstance(t, str) and t.strip() for t in topics):
            raise ValueError("topics must be a non-empty list of strings")
        if not domain_scope or not isinstance(domain_scope, str):
            raise ValueError("domain_scope must be a non-empty string")

        # Call updated create_collection with mandatory fields
        collection_id = coll_mgr.create_collection(
            name=name,
            description=description,
            domain=domain,
            topics=topics,
            domain_scope=domain_scope,
            metadata_schema=metadata_schema,
        )

        collection = coll_mgr.get_collection(name)

        return {
            "collection_id": collection_id,
            "name": name,
            "description": description,
            "domain": domain,
            "topics": topics,
            "domain_scope": domain_scope,
            "metadata_schema": collection.get("metadata_schema"),
            "created": True,
        }
    except ValueError as e:
        logger.warning(f"create_collection failed: {e}")
        raise
    except Exception as e:
        logger.error(f"create_collection failed: {e}")
        raise
```

---

#### Change 3.2: Update `update_collection_metadata_impl()` docstring and return value

**Lines 168-207 - `update_collection_metadata_impl()` function**

**Current behavior:** Updates custom fields only

**New behavior:** Adds support for updating topics (with merging), prevents updates to domain/domain_scope

**Docstring update:**
```python
def update_collection_metadata_impl(
    coll_mgr: CollectionManager,
    collection_name: str,
    new_fields: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Implementation of update_collection_metadata MCP tool.

    Updates a collection's metadata schema (additive only, mandatory fields immutable).

    MANDATORY FIELD UPDATE RULES:

    domain and domain_scope: IMMUTABLE - cannot be changed after creation.
        Attempting to change these fields will raise ValueError.

    topics: ADDITIVE-ONLY - new topics can be added, existing topics preserved.
        When updating topics, provide the new topics to ADD:
        {
            "mandatory": {
                "topics": ["new_topic_1", "new_topic_2"]
            }
        }
        System will merge new topics with existing (deduplicating), so you don't need to
        provide the full list - just the new ones you want to add.

    CUSTOM FIELD UPDATE RULES:

    New custom fields can be added (required=false, additive-only).
    Existing custom fields cannot be removed or have types changed.

    Args:
        coll_mgr: CollectionManager instance
        collection_name: Collection name to update
        new_fields: New schema fields to add/merge. Format:
            {
                "mandatory": {
                    "topics": ["new_topic_1", "new_topic_2"]  # Merged with existing
                },
                "custom": {
                    "new_field": {"type": "string", "required": false}
                }
            }

    Returns:
        {
            "name": str,
            "description": str,
            "metadata_schema": dict,
            "fields_added": int,
            "topics_added": int,
            "total_topics": int,
            "total_custom_fields": int
        }

    Raises:
        ValueError: If trying to change immutable fields (domain, domain_scope),
                   remove custom fields, or violate additive-only constraints

    Example:
        result = update_collection_metadata_impl(
            coll_mgr,
            "quantum-computing",
            {
                "mandatory": {
                    "topics": ["quantum error correction"]  # Add this topic
                },
                "custom": {
                    "year_published": {"type": "number"}  # Add this field
                }
            }
        )
    """
    try:
        # Get current state before update
        current = coll_mgr.get_collection(collection_name)
        if not current:
            raise ValueError(f"Collection '{collection_name}' not found")

        current_topics = current.get("metadata_schema", {}).get("mandatory", {}).get("topics", [])
        current_custom_count = len(current["metadata_schema"].get("custom", {}))

        # Update the schema (handles mandatory validation and topics merging)
        updated = coll_mgr.update_collection_metadata_schema(collection_name, new_fields)

        new_topics = updated.get("metadata_schema", {}).get("mandatory", {}).get("topics", [])
        new_custom_count = len(updated["metadata_schema"].get("custom", {}))

        return {
            "name": updated["name"],
            "description": updated["description"],
            "metadata_schema": updated["metadata_schema"],
            "fields_added": new_custom_count - current_custom_count,
            "topics_added": len(new_topics) - len(current_topics),
            "total_topics": len(new_topics),
            "total_custom_fields": new_custom_count
        }
    except ValueError as e:
        logger.warning(f"update_collection_metadata failed: {e}")
        raise
    except Exception as e:
        logger.error(f"update_collection_metadata error: {e}")
        raise
```

---

#### Change 3.3: Update `get_collection_metadata_schema_impl()` to return mandatory and custom fields only

**Lines 246-279 - `get_collection_metadata_schema_impl()` function**

**Current behavior:** Returns custom and system fields separately

**New behavior:** Returns ONLY mandatory and custom fields. System fields are NOT included.

**Rationale for excluding system fields:**
- System fields are internal implementation details, not part of the public schema contract
- LLMs cannot realistically use system fields for filtering (don't know values, unreliable detection)
- System fields may change with implementation improvements
- If system field filtering becomes needed later, it's a separate discovery mechanism
- The schema's purpose: "What do you declare about this collection?" Answer: mandatory + custom fields only

**New implementation:**
```python
def get_collection_metadata_schema_impl(
    coll_mgr: CollectionManager, collection_name: str
) -> Dict[str, Any]:
    """
    Implementation of get_collection_metadata_schema MCP tool.

    Returns the metadata schema for a collection showing what fields to use when ingesting
    and what fields define the collection's scope.

    MANDATORY FIELDS (collection-scoped, immutable/additive):
    - domain: Single knowledge domain (immutable)
    - topics: Topics within domain (additive-only array)
    - domain_scope: Domain boundaries description (immutable)
    These define what the collection is about and what documents should provide.

    CUSTOM FIELDS (user-defined, required/optional):
    - User-declared fields for metadata on documents
    - Each field specifies type and whether it's required when ingesting
    - New fields can be added later, existing ones never removed

    Args:
        coll_mgr: CollectionManager instance
        collection_name: Collection name to retrieve schema for

    Returns:
        {
            "collection_name": str,
            "description": str,
            "document_count": int,

            "metadata_schema": {
                "mandatory_fields": {
                    "domain": {
                        "type": "string",
                        "value": str,
                        "immutable": true,
                        "description": "..."
                    },
                    "topics": {
                        "type": "array",
                        "item_type": "string",
                        "value": [str],
                        "enum": [str],  # Same as value - allowed values for filtering/ingesting
                        "additive_only": true,
                        "description": "..."
                    },
                    "domain_scope": {
                        "type": "string",
                        "value": str,
                        "immutable": true,
                        "description": "..."
                    }
                },

                "custom_fields": {
                    "field_name": {
                        "type": "string|number|array|object|boolean",
                        "required": true|false,
                        "enum": [...],  # optional, for constrained fields
                        "description": "..."
                    },
                    ...
                }
            }
        }

    Raises:
        ValueError: If collection not found
    """
    try:
        collection = coll_mgr.get_collection(collection_name)
        if not collection:
            raise ValueError(f"Collection '{collection_name}' not found")

        schema = collection.get("metadata_schema", {})
        mandatory = schema.get("mandatory", {})
        custom = schema.get("custom", {})

        # Build mandatory fields section
        mandatory_fields = {}
        if mandatory:
            mandatory_fields["domain"] = {
                "type": "string",
                "value": mandatory.get("domain"),
                "immutable": True,
                "description": "Single knowledge domain for this collection. Set at creation, cannot be changed."
            }
            mandatory_fields["topics"] = {
                "type": "array",
                "item_type": "string",
                "value": mandatory.get("topics", []),
                "enum": mandatory.get("topics", []),  # Allowed values when ingesting documents
                "additive_only": True,
                "description": "Topics within domain. When ingesting documents, select from these values. New topics can be added via collection update."
            }
            mandatory_fields["domain_scope"] = {
                "type": "string",
                "value": mandatory.get("domain_scope"),
                "immutable": True,
                "description": "Natural language definition of domain boundaries (what is/isn't in scope). Set at creation, cannot be changed."
            }

        # Build custom fields section
        custom_fields = {}
        for name, field_def in custom.items():
            custom_fields[name] = {
                "type": field_def.get("type", "string"),
                "required": field_def.get("required", False),
                "description": field_def.get("description", "")
            }
            # Include enum if present
            if "enum" in field_def:
                custom_fields[name]["enum"] = field_def["enum"]

        return {
            "collection_name": collection_name,
            "description": collection["description"],
            "document_count": collection["document_count"],
            "metadata_schema": {
                "mandatory_fields": mandatory_fields,
                "custom_fields": custom_fields
            }
        }
    except ValueError as e:
        logger.warning(f"get_collection_metadata_schema failed: {e}")
        raise
    except Exception as e:
        logger.error(f"get_collection_metadata_schema failed: {e}")
        raise
```

---

### 4. Integration with Ingestion (`src/unified/mediator.py`)

#### Change 4.1: Call validation in `ingest_text()`

**Lines 55-134 - `ingest_text()` method**

**Add validation call after RAG ingestion:**
```python
# After line 96 (RAG ingestion completed)
# Add optional validation of document metadata against collection
try:
    self.rag_store.collection_mgr.validate_document_mandatory_fields(
        collection_name, metadata or {}
    )
except ValueError:
    # Log but don't fail - guidance only
    pass
```

**Docstring note:** Add clarification that metadata should include domain/topics matching collection, for guidance.

---

### 5. Complete Sample Response from `get_collection_metadata_schema`

**Request:**
```
get_collection_metadata_schema(collection_name="quantum-computing")
```

**Response:**
```json
{
  "collection_name": "quantum-computing",
  "description": "Quantum computing research, theory, and applications",
  "document_count": 42,

  "metadata_schema": {
    "mandatory_fields": {
      "domain": {
        "type": "string",
        "value": "quantum computing",
        "immutable": true,
        "description": "Single knowledge domain for this collection. Set at creation, cannot be changed."
      },
      "topics": {
        "type": "array",
        "item_type": "string",
        "value": ["quantum entanglement", "quantum algorithms", "quantum hardware", "quantum error correction"],
        "enum": ["quantum entanglement", "quantum algorithms", "quantum hardware", "quantum error correction"],
        "additive_only": true,
        "description": "Topics within domain. When ingesting documents, select from these values. New topics can be added via collection update."
      },
      "domain_scope": {
        "type": "string",
        "value": "Covers quantum computing theory and applications. Includes: quantum mechanics foundations, quantum algorithms (Shor's, Grover's, VQE), quantum hardware (superconducting qubits, ion traps, photonic), error correction codes. Excludes: quantum biology, quantum cryptography outside of quantum computing context.",
        "immutable": true,
        "description": "Natural language definition of domain boundaries (what is/isn't in scope). Set at creation, cannot be changed."
      }
    },

    "custom_fields": {
      "paper_type": {
        "type": "string",
        "required": true,
        "enum": ["research", "review", "tutorial"],
        "description": "Type of academic paper. Must be provided when ingesting."
      },
      "year_published": {
        "type": "number",
        "required": false,
        "description": "Publication year. Optional when ingesting."
      },
      "difficulty_level": {
        "type": "string",
        "required": false,
        "enum": ["beginner", "intermediate", "advanced"],
        "description": "Difficulty level for learning resources. Optional when ingesting."
      },
      "keywords": {
        "type": "array",
        "item_type": "string",
        "required": false,
        "description": "Custom keywords for this document. Optional when ingesting."
      }
    }
  }
}
```

**What LLM understands from this:**

1. **Is this the right collection?** Domain, description, and already has 42 docs - good context.

2. **What MUST I provide when ingesting?**
   - `domain`: Must be exactly "quantum computing"
   - `topics`: Must select one or more from the 4 allowed topics
   - `paper_type`: Required custom field, must be one of ["research", "review", "tutorial"]

3. **What CAN I optionally provide?**
   - `year_published`: Optional number
   - `difficulty_level`: Optional, pick from ["beginner", "intermediate", "advanced"]
   - `keywords`: Optional array of strings

4. **What should I NOT provide?**
   - System fields (they're auto-generated)

---

### 6. Database Migration Path

NO MIGRATIONS NEEDED. Since there are no existing users, tear down existing schemas and deploy clean with mandatory fields from the start.

---

## Implementation Checklist (Not Yet Started)

- [ ] Modify `src/core/collections.py`:
  - [ ] Update `create_collection()` signature and logic
  - [ ] Update `_validate_metadata_schema()`
  - [ ] Add `validate_document_mandatory_fields()`
  - [ ] Update `update_collection_metadata_schema()` for immutability and topics merging

- [ ] Modify `src/mcp/tools.py`:
  - [ ] Update `create_collection_impl()` signature and docstring
  - [ ] Update `update_collection_metadata_impl()` docstring and return value
  - [ ] Update `get_collection_metadata_schema_impl()` to categorize and return mandatory fields

- [ ] Modify `src/unified/mediator.py`:
  - [ ] Add validation call in `ingest_text()`

- [ ] Create alembic migration:
  - [ ] 002_add_mandatory_fields_to_existing_collections.py

- [ ] Update tests:
  - [ ] Modify `test_collection_metadata_schema.py` for mandatory fields
  - [ ] Add tests for topics merging (additive-only)
  - [ ] Add tests for immutable field validation (domain, domain_scope)

- [ ] Update docstrings and comments throughout

---

**Last Updated:** Analysis complete, ready for user review
**Status:** Awaiting approval before implementation

